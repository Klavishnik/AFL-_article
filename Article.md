L (American Fuzzy Lop) и его современная версия AFL++ — это один из самых мощных инструментов для поиска уязвимостей в программах. Этот фаззер используется для тестирования разных типов бинарных файлов и стал стандартом в большинстве современных кампаний по фаззингу.

AFL++ — это не просто генератор случайных данных. Он использует метод фаззинга, основанный на покрытии кода (coverage-based fuzzing). Основная идея этого подхода заключается в отслеживании тех участков программы, которые исполняются при подаче определенных данных на вход программы. Таким образом, можно понять, какие входные данные активируют конкретные части программы. На основе этой информации AFL++ формирует базу данных входных данных, которая постепенно покрывает весь код программы, а не только ее основные или часто используемые участки - этот процесс называется *мутацией*. Это позволяет находить ошибки даже в тех местах, которые обычно остаются без внимания.



Давайте рассмотрим работу AFL++ на конкретном пример кода:
```C
int main(){
	input = get_in(); функция-заглушка, для получение ввода из файл / stdin или каким-то другим способом.
	if(condition_A){
		...code_A...
	}else if(condition_B){
		...code_B ..
	}else{
		...code_C...
	}
	return 0;
}
```
Предположим, у нас есть определенный набор данных, подав который с помощью функции `get_in()`, мы выполним участок кода `code_C`. 
> Выполнение уникакальной трассы кода будем называть `edge` (или ребро). 
> Набор данных, котрый приводит к открытию нового `edge` будем называть `seed` (сид).
> Совокупность `seed'ов` будем называть `corpus` (корпус).
> `Seed`, который приводит к аварийному завершению исследуемой программы, будем называть `crash` (краш / падение).
> `Seed`, который приводит к зависманию исследуемой программы, будем называть `hangs` (зависание)
>  Совокупность сидов, крашей и зависаний (выходные данные фаззинга), будем называть `артефактами фаззинга`

Теперь предположим, что мы каким-то образом изменяем `seed` (напоминаю, в фаззинге этот процесс называется `мутацией`), получая новый входной файл — `seed_A`. При вводе `seed_A` программа выполняет секцию `code_A`, который ранее не выполнялся. Это новое поведение. Зная, что `seed_A` приводит к выполнению нового участка кода `code_A`, мы можем сохранить `seed_A` в нашем корпусе для дальнейших мутаций, чтобы исследовать другие части кода.
Именно этот итеративный процесс поиска новых ребер, за счет изменения данных и работы с ними делает фаззинг на основе покрытия таким мощным подходом.

## Архитектура AFL++

Разделим данную статью на две логические части:
- В первой мы будем рассматривать сам фаззер и разбираться в работе его утилиты `afl-fuzz`;
- Во-второй рассмотрим процесс инструментации кода компиляторами `afl-c++` и `afl-cc`. 

### Архитектура afl-fuzz

Типичная команда запуска фаззера выглядит примерно так:
```bash
afl-fuzz -i in -o out -- ./bin [@@]
```
Немного подробнее про опции:
- `-i` - путь до директории с начальным (входным) корпусом данным (**Важно!** наборы данных в этой папке не должны приводить к падению или зависанию программы);
- `-o` - путь, куда будут сохраняться выходные данные фаззера (артефакты)
- `--` такими символами разграничиваются опции утилиты `afl-fuzz` и опции исследуемой программы;
- `bin` - путь до исследуемой программы
- `[@@]` - специальная опция afl-fuzz. При отсутствии символов `@@` фаззер будет подавать данные на программу из потока. Если запустить `afl-fuzz`, выставив символы `@@`, то на вход исследуемой программы сиды будут подаваться как файлы.

Итак, немного глубже рассмотрим то, как происходит запуск и работа утилиты `afl-fuzz`:

Когда запускается `afl-fuzz`, выполняется серия функций инициализации. После этого `afl-fuzz` создает дочерний процесс с помощью `fork`. Дочерний же процесс выполняет   запуск исслудемой программы (цели)  с помощью функции `exec`. Однако, фаззинг тестирование **не** начинается в дочернем процессе. Вместо этого дочерний процесс останавливается прямо перед вызовом функции `main` и становится `forkserve'омr`.

Этот `forkserver` создаёт новый дочерний процесс (дочерний процесс дочернего процесса - внука), и уже в этом процессе (внуке) запускается фаззинг тестирование. 
Такой подход связан с тем, что `fork` работает гораздо быстрее, чем `exec`, поэтому резонно запускать фаззинг именно в процессе - внуке, а не в главном или дочернем процессе, ведь такой подход позвляет повысить скорость фаззинг тестирования, что очень важно. 
> Процесс фаззинг тестирования базируется на постоянном перезапуске исследуемой программы (кроме `persistant mode`, но об этом ниже). 
> Зачастую количество запусков исследуемой программы при грамотно написанной фаззинг обертке и компиляции с механизмами `llvm` достигает сотен тысяч в секунду.


Чтобы `afl-fuzz` мог взаимодействовать с бинарным файлом исследуемой программы (будем его так же называть *целевым файлом*), создаются два канала (`pipe`): управляющий канал (`control pipe`) и канал статуса (`status pipe`).

- Управляющий канал находится по адресу `FORKSRV_FD` и используется для отправки сообщений управления в целевой бинарный файл. Этот канал доступен для чтения только целевому бинарному файлу и для записи только `afl-fuzz`.
- Канал статуса находится по адресу `FORKSRV_FD+1` и используется для передачи статусов обратно в `afl-fuzz`. Этот канал доступен для записи только целевому бинарному файлу и для чтения только `afl-fuzz`.

*Управляющий канал используется для передачи управляющих сообщений в целевой бинарный файл.*
*Канал статуса — для отправки ответных сообщений в `afl-fuzz`.*

Теперь, когда у нас есть общее представление о том, как запускается `afl-fuzz`, давайте более подробно разберём почему AFL++ `coverage-based`.

## Инструментация и сбор покрытия кода
Для работы AFL++ бинарный файл должен быть скомпилирован специальным компилятором AFL++. При компиляции происходит инструментация бинарно файла специальными инструкциями AFL++. Это необходимо для того, чтобы фаззер мог отслеживать открытие новых ребер с помощью мутированных данных при фаззинг тестировании. Это и назыается покрытием кода.
Факт открытия нового ребра сохраняется в специальный массив, который называется "картой покрытия" (подробнее о нём будет ниже).

В настоящее время AFL++ позволяет использовать различные системы сборы покрытия, но наиболее распространнеными являются `PCGUARD` и `LTO`.
Получить доступ к этим инструментациям можно с помощью базовых компиляторов AFL++:
- `PCGUARD` инструментация предоставляется компилятором afl-clang-fast.
- `LTO` инструменацтия предоставляется компилятором afl-clang-lto.

Об особенностях компиляции и выборе подходящего компилятор подробно рассказывается в [документации](https://github.com/AFLplusplus/AFLplusplus/tree/ea14f3fd40e32234989043a525e3853fcb33c1b6/docs) на AFL++. 
Если коротко, то изменения компилятора так же влияет и на скорость фаззинга. 
Выбор способа инструментирования кода по скорости от лучшего к худшему:
```
LTO (afl-clang-lto) -> LLVM  (afl-clang-fast) -> GCC_plugin (afl-gcc-fast) -> GCC (afl-gcc)
```

Теперь давайте рассмотрим инструментацию кода на практике. 
Пусть у нас есть простейшая программа, которая принимает и обрабатывает данные из потока ввода:

```C
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <readline/readline.h>
#define SIZE 10

int main()
{
        char *str = readline("Enter your string \n");
        char * array = malloc(SIZE * sizeof(char));
        if(str == NULL)
                return 0;
        strcpy(array, str);
        printf("%s", array);
        free(str);
        free(array);
        return 0;
}
```

Скомпилируем её с инструментацией `PCGUARD`
```bash
afl-clang-fast main.c -lreadline -o bin_fast
```

И декомпилируем получившийся исполняемый файл в IDA PRO:

```c
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char *v3; // rbx
  char *v4; // r14

  *((_BYTE *)_afl_area_ptr + _start___sancov_guards) += __CFADD__(*((_BYTE *)_afl_area_ptr + _start___sancov_guards), 1)
                                                      + 1;
  v3 = (char *)readline("Enter your string \n", argv);
  v4 = (char *)malloc(0xAuLL);
  if ( v3 )
  {
    *((_BYTE *)_afl_area_ptr + dword_91A0) += __CFADD__(*((_BYTE *)_afl_area_ptr + dword_91A0), 1) + 1;
    strcpy(v4, v3);
    printf("%s", v4);
    free(v3);
    free(v4);
  }
  else
  {
    *((_BYTE *)_afl_area_ptr + dword_919C) += __CFADD__(*((_BYTE *)_afl_area_ptr + dword_919C), 1) + 1;
  }
  return 0;
}
```

Внимательный читатель обратит внимание на появищиеся конструкции, которые сопровождает перемення `_afl_area_ptr`.
Помните выше мы ввели термин *карта покрытия* так вот - это  `_afl_area_ptr`. `_afl_area_ptr` - это массив, к которому осуществляется доступ каждый раз при достижении новой области. Обратите внимание, что есть доступ к `__afl_area_ptr` происходит во всех ветвелниях кода  - в операторе if и в операторе else.

Давайте внимательнее разберем строку:
```C
  *((_BYTE *)_afl_area_ptr + dword_91A0) += __CFADD__(*((_BYTE *)_afl_area_ptr + dword_91A0), 1) + 1;
```
Переменная `dword_91A0` IDA  PRO инициализированна нулем и никак не изменяет значение на протяжении работы функции `main`.
`_afl_area_ptr` по определени будем счиать байтовым массивом, поэтому уберем приведение типов.
Итак, строка кода теперь выглядит так:
```C
  *_afl_area_ptr += __CFADD__(*_afl_area_ptr, 1) + 1;
```
`__CFADD__` - макрос, который выполняет сложение (в нашем случае с единицей) с учетом переноса.

Итак, данная строка кода, при её выполнении, инкрементирует значение элемента мамсива карты покрытия фаззера. 
Т.е. в карте покрытия за каждый участок кода отвечает свой элемент массива (напоминаю, что массив байтовый). При открытии нового ребра в определенном учатке происходит увеличения значения определенного элемента массива. Именно так реализовано получение обратной связи фаззером.

В PCGUARD индекс __afl_area_ptrдоступа определяется во время выполнения. В частности, значение переменной DAT_*заполняется во время выполнения. 


