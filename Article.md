## От автора 
Написание этой статьи было вызвано отсутствием комплексных материалов о структуре фаззера AFL++ на русском языке, а также необходиомтью устранить собственные пробелы в знаниях.

На протяжении всей статьи будут приведены ссылки на исходный код, который относится к последней стабильной версии AFL++ 4.30. Всё, что описано в статье, основывается именно на этой версии, но с высокой вероятностью будет актуально как для более старых, так и для более новых версий, так как затрагивает основные механизмы работы этого фаззера.

## Введние 
AFL (American Fuzzy Lop) и его современная версия AFL++ — это один из самых мощных инструментов для поиска уязвимостей в программах. Этот фаззер используется для тестирования разных типов бинарных файлов и стал стандартом фаззинга.

AFL++ — это не просто генератор случайных данных. Он использует метод фаззинга, основанный на покрытии кода (`coverage-based fuzzing`). Основная идея этого подхода заключается в отслеживании тех участков программы, которые исполняются при подаче определенных данных на вход программы. Таким образом, можно понять, какие входные данные активируют конкретные части программы. На основе этой информации AFL++ формирует базу данных входных данных, которая постепенно покрывает весь код программы, а не только ее основные или часто используемые участки - этот процесс называется *мутацией*. Это позволяет находить ошибки даже в тех местах, которые обычно остаются без внимания.



Давайте рассмотрим работу AFL++ на конкретном пример кода:
```C
int main(){
	input = get_in(); функция-заглушка, для получение ввода из файл / stdin или каким-то другим способом.
	if(condition_A){
		...code_A...
	}else if(condition_B){
		...code_B ..
	}else{
		...code_C...
	}
	return 0;
}
```
Предположим, у нас есть определенный набор данных, подав который с помощью функции `get_in()`, мы выполним участок кода `code_C`. 
> Выполнение уникакальной трассы кода будем называть `edge` (или ребро). 
>
> Набор данных, котрый приводит к открытию нового `edge` будем называть `seed` (сид).
> 
> Совокупность `seed'ов` будем называть `corpus` (корпус).
> 
> `Seed`, который приводит к аварийному завершению исследуемой программы, будем называть `crash` (краш / падение).\
> 
> `Seed`, который приводит к зависманию исследуемой программы, будем называть `hangs` (зависание)
> 
>  Совокупность сидов, крашей и зависаний (выходные данные фаззинга), будем называть `артефактами фаззинга`

Теперь предположим, что мы каким-то образом изменяем `seed` (напоминаю, в фаззинге этот процесс называется `мутацией`), получая новый входной файл — `seed_A`. При вводе `seed_A` программа выполняет секцию `code_A`, который ранее не выполнялся. Это новое поведение. 
Зная, что `seed_A` приводит к выполнению нового участка кода `code_A`, мы можем сохранить `seed_A` в нашем корпусе для дальнейших мутаций, чтобы исследовать другие части кода.
Именно этот итеративный процесс поиска новых ребер, за счет изменения данных и работы с ними делает фаззинг на основе покрытия таким мощным подходом.


### Архитектура afl-fuzz

Типичная команда запуска фаззера выглядит примерно так:
```bash
afl-fuzz -i in -o out -- ./bin [@@]
```
Немного подробнее про опции:
- `-i` - путь до директории с начальным (входным) корпусом данным (**Важно!** наборы данных в этой папке не должны приводить к падению или зависанию программы);
- `-o` - путь, куда будут сохраняться выходные данные фаззера (артефакты)
- `--` такими символами разграничиваются опции утилиты `afl-fuzz` и опции исследуемой программы;
- `bin` - путь до исследуемой программы
- `[@@]` - специальная опция afl-fuzz. При отсутствии символов `@@` фаззер будет подавать данные на программу из потока. Если запустить `afl-fuzz`, выставив символы `@@`, то на вход исследуемой программы сиды будут подаваться как файлы.

Итак, немного глубже рассмотрим то, как происходит запуск и работа утилиты `afl-fuzz`:

Когда запускается `afl-fuzz`, выполняется серия функций инициализации. После этого `afl-fuzz` создает дочерний процесс с помощью `fork`. Дочерний же процесс выполняет   запуск исслудемой программы (цели)  с помощью функции `exec`. Однако, фаззинг тестирование **не** начинается в дочернем процессе. Вместо этого дочерний процесс останавливается прямо перед вызовом функции `main` и становится `forkserve'омr`.

Этот `forkserver` создаёт новый дочерний процесс (дочерний процесс дочернего процесса - внука), и уже в этом процессе (внуке) запускается фаззинг тестирование. 
Такой подход связан с тем, что `fork` работает гораздо быстрее, чем `exec`, поэтому резонно запускать фаззинг именно в процессе - внуке, а не в главном или дочернем процессе, ведь такой подход позвляет повысить скорость фаззинг тестирования, что очень важно. 
> Процесс фаззинг тестирования базируется на постоянном перезапуске исследуемой программы (кроме `persistant mode`, но об этом ниже). 
> Зачастую количество запусков исследуемой программы при грамотно написанной фаззинг обертке и компиляции с механизмами `llvm` достигает сотен тысяч в секунду.


Чтобы `afl-fuzz` мог взаимодействовать с бинарным файлом исследуемой программы (будем его так же называть *целевым файлом*), создаются два канала (`pipe`): управляющий канал (`control pipe`) и канал статуса (`status pipe`).

- Управляющий канал находится по адресу `FORKSRV_FD` и используется для отправки сообщений управления в целевой бинарный файл. Этот канал доступен для чтения только целевому бинарному файлу и для записи только `afl-fuzz`.
- Канал статуса находится по адресу `FORKSRV_FD+1` и используется для передачи статусов обратно в `afl-fuzz`. Этот канал доступен для записи только целевому бинарному файлу и для чтения только `afl-fuzz`.

*Управляющий канал используется для передачи управляющих сообщений в целевой бинарный файл.*
*Канал статуса — для отправки ответных сообщений в `afl-fuzz`.*

Теперь, когда у нас есть общее представление о том, как запускается `afl-fuzz`, давайте более подробно разберём почему AFL++ `coverage-based`.

## Инструментация и сбор покрытия кода
Для работы AFL++ бинарный файл должен быть скомпилирован специальным компилятором AFL++. При компиляции происходит инструментация бинарно файла специальными инструкциями AFL++. Это необходимо для того, чтобы фаззер мог отслеживать открытие новых ребер с помощью мутированных данных при фаззинг тестировании. Это и назыается покрытием кода.
Факт открытия нового ребра сохраняется в специальный массив, который называется "картой покрытия" (подробнее о нём будет ниже).

В настоящее время AFL++ позволяет использовать различные системы инструментации кода для дальнейшего сбора покрытия, но наиболее распространнеными являются `PCGUARD` и `LTO`.
Получить доступ к этим инструментациям можно с помощью базовых компиляторов AFL++:
- `PCGUARD` инструментация предоставляется компилятором `afl-clang-fast`.
- `LTO` инструменацтия предоставляется компилятором `afl-clang-lto`.

Об особенностях компиляции и выборе подходящего компилятор подробно рассказывается в [документации](https://github.com/AFLplusplus/AFLplusplus/tree/v4.30c/docs) на AFL++. 
Если коротко, то изменения компилятора так же влияет и на скорость фаззинга. 
Выбор способа инструментирования кода по скорости от лучшего к худшему:
```
LTO (afl-clang-lto) -> LLVM  (afl-clang-fast) -> GCC_plugin (afl-gcc-fast) -> GCC (afl-gcc)
```

Так же различные компиляторы отличаются не только скоростью фаззинга, но и требованием к версии `clang` и `llvm`.

Теперь давайте рассмотрим инструментацию кода на практике. 
Пусть у нас есть простейшая программа, которая принимает и обрабатывает данные из потока ввода:

```C
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <readline/readline.h>
#define SIZE 10

int main()
{
        char *str = readline("Enter your string \n");
        char * array = malloc(SIZE * sizeof(char));
        if(str == NULL)
                return 0;
        strcpy(array, str);
        printf("%s", array);
        free(str);
        free(array);
        return 0;
}
```

Скомпилируем её с инструментацией `PCGUARD`
```bash
afl-clang-fast main.c -lreadline -o bin_fast
```

И декомпилируем получившийся исполняемый файл в IDA PRO:

![bin_fast_decomp](images/bin_fast_decomp.png)


Внимательный читатель обратит внимание на появищиеся конструкции, которые сопровождает переменная `_afl_area_ptr`.
Помните выше мы ввели термин *карта покрытия*? Так вот - это  `_afl_area_ptr`. 

`_afl_area_ptr` - это массив, к которому осуществляется доступ каждый раз при достижении новой области. Обратите внимание, что есть доступ к `__afl_area_ptr` происходит во всех ветвлениях кода  - в операторе `if` и в операторе `else`.

Давайте внимательнее разберем строки 12 и 20:
```C
12 |  *((_BYTE *)_afl_area_ptr + dword_91A0) += __CFADD__(*((_BYTE *)_afl_area_ptr + dword_91A0), 1) + 1;
20 |  *((_BYTE *)_afl_area_ptr + dword_919C) += __CFADD__(*((_BYTE *)_afl_area_ptr + dword_919C), 1) + 1;
```
`_afl_area_ptr` по определени будем счиать байтовым массивом, поэтому уберем приведение типов.
Метки `dword_91A0` и `dword_919C` в IDA PRO явяются указателями на участок памяти и относятся к массиву нашей карты памяти, что видно далее:

![map_init_sancov](images/map_init_sancov.png)

Инструкции с паттерном `*sancov*` являются следствием инструментации компилятора - таким способом выделяется секция данных для карты покрытия по ребрам. 

Наглядно видно, что метки `dword_919C` и `dword_91A0`  идут последовательно друг за другом и инициализируются нулем, а значит метка `dword_919C` явялется нулевым элементом массива карты покрытия, а `dword_91A0` - первым.


Теперь преобразованные строки инструментации кода  выглядят так:
```C
12 |*_afl_area_ptr[1] += __CFADD__(*_afl_area_ptr, 1) + 1;
20 |*_afl_area_ptr[0] += __CFADD__(*_afl_area_ptr, 1) + 1;
```
`__CFADD__` - макрос, который выполняет сложение (в нашем случае с единицей) с учетом переноса.

```C
12 | _afl_area_ptr[1] =_afl_area_ptr[1] + 1 + (__afl_area_ptr[1] == 255 ? 1 : 0);
20 | _afl_area_ptr[0] =_afl_area_ptr[0] + 1 + (__afl_area_ptr[0] == 255 ? 1 : 0);
```

[Исходник](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/instrumentation/afl-compiler-rt.o.c#L1406)

Итак, данная строка кода, при её выполнении, инкрементирует значение элемента масива карты покрытия фаззера. 
То есть, в карте покрытия за каждый участок кода отвечает свой элемент массива (напоминаю, что массив байтовый). При открытии нового ребра в определенном учатке происходит увеличения значения определенного элемента массива. Именно так реализовано получение обратной связи фаззером.


Теперь обратим внимание на инструментацию `LTO`, на те же строки 12 и 20:
![bin_lto_decomp](images/bin_lto_decomp.png)


Инструментация `LTO` очень похожа на `PCGUARD`, за исключением того, что индекс `_afl_area_ptr` заполняется во время компиляции, а не во время выполнения. Это видно на тех же строках 12 и 20 -  здесь уже нет подсчета адреса массива через адреса и метки, вместо этого используется адресация со смещением, где `offset` - смещение, было подсчитано уже во время компиляции и имеет конкретное значение.


### Инструментация кода

Давайте попытаемся разобраться, как вообще происходит инструментация кода. 
Если тезисно, то `AFL++` использует механизмы сбора покрытия кода, предоставляемые `LLVM`

Подробнее об этом можно почитать в [документации](https://clang.llvm.org/docs/SanitizerCoverage.html)

Данный механизм позволяет вставлять специальные вызовы в пользовательские функции на уровне функций, базовых блоков и рёбер. 
Для активации данного механизма необходимо добавить специальные флаги компиляции, благо `AFL++` делает это [самостоятельно](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/src/afl-cc.c#L2057), причем добавляет и ряд дополнительных опций: `-fsanitize-coverage=trace-pc-guard,bb,no-prune,pc-table`: 

- `trace-pc-guard`  - инструментация сбора покрытия после **каждого ребра**;
- `bb` - инструментация сбора покрытия после каждого **базового блока**;
- `no-prune` - позвоялет убрать отсчение некоторой информации при сборе покрытия;
- `pc-table` - инструментация создает таблитцу, которая содержит пары [PC (Адрес базового блока.), PCFlags (Флаги, описывающие свойства базового блока)].  Позволяет отслеживать пути выполнения, которые привели к определенному состоянию.

Согласно документации `LLVM` использование таких инструментаций приводит к добавлению специальных вызовов функций в определенные участики кода (в зависимости от выбранного типа инструментации). Также это накладывает на пользователя необходимость [переодпределения](https://clang.llvm.org/docs/SanitizerCoverage.html#:~:text=The%20functions%20__sanitizer_cov_trace_pc_*%20should%20be%20defined%20by%20the%20user.)  реализаций данных функций, что реализовано в AFL++, например [изменение инструментации создания PCs таблицы](https://github.com/AFLplusplus/AFLplusplus/blob/10db3a35cf17600594946edb6662d606bd4e4207/custom_mutators/libfuzzer/FuzzerTracePC.cpp#L548):

```C
void __sanitizer_cov_pcs_init(const uintptr_t *pcs_beg,
                              const uintptr_t *pcs_end) {

  fuzzer::TPC.HandlePCsInit(pcs_beg, pcs_end);

}
```
Или [изменение инструментации сбора покрытия после каждого **ребра**](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/instrumentation/afl-compiler-rt.o.c#L1365).



### Инициализация и запуск forkserver

Прежде чем обсуждать процесс инициализации, нам нужно рассмотреть одну из особенностей `ELF`-файлов, известную как `init array`.

Когда исполняемый бинарный файл запускается, функция `main` не вызывается напрямую. Вместо этого выполнение всегда начинается с интерпретатора (обычно это `ld.so`). Интерпретатор выполняет множество ключевых операций по настройке структуры процессов, таких как динамическая линковка. Однако менее известной особенностью интерпретатора является его способность запускать функции инициализации. Эти функции инициализации находятся в секции, называемой `.init_array`. Эта секция содержит массив функций, которые выполняются последовательно, прямо перед вызовом `main`. Это наглядно можно увидеть в коде [glibc](https://github.com/bminor/glibc/blob/9e2ff880f3cbc0b4ec8505ad2ce4a1c92d7f6d56/elf/dl-init.c#L70) и в почитать в [документации](https://www.gnu.org/software/hurd/glibc/startup.html)



Функции в секции `.init_array` зависят от того, был ли бинарный файл скомпилирован с использованием инструментаций `PCGUARD` или `LTO` (однако, как мы убедились выше, в большинстве случаев они остаются одинаковыми).

В процессе обсуждения функций из `.init_array`  нам встретятся различные переменные, переменные окружения и макросы. Для удобства привожу их определения ниже:

**Обычные переменные:**

- `__afl_area_ptr` — Указатель на карту покрытия. [По умолчанию это](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/instrumentation/afl-compiler-rt.o.c#L109) `__afl_area_initial`. Размер `__afl_area_initial` [равен](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/instrumentation/afl-compiler-rt.o.c#L105) `MAP_INITIAL_SIZE`.
- `__afl_final_loc` — Последний индекс в `__afl_area_ptr`, к которому был осуществлен доступ при помощи инструментации. По сути это конец массива карты покрытий. 
- `__afl_map_addr` — Адрес, по которому карта покрытия будет отображена через mmap. Эта переменная существует только в случае, если `AFL_LLVM_MAP_ADDR` установлен в режиме `LTO`. В противном случае её значение равно 0.
- `__afl_map_size` — Размер карты покрытия.
- `__afl_area_initial` — указатель на массив, который является картой покрытия и используется в общей (разделяемой) памяти между инстансами `afl-fuzz`.

**Переменные окружения:**

- `__AFL_SHM_ID` ([алиас](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/include/config.h#L405) на  `SHM_ENV_VAR`) — Идентификатор общей памяти для карты покрытия.
- `__AFL_SHM_FUZZ_ID` ([алиас](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/include/config.h#L409) `SHM_FUZZ_ENV_VAR`) — Идентификатор общей памяти для фаззинга через общую память.
- `AFL_MAP_SIZE` — Используется для задания размера буфера общей памяти, выделяемого `afl-fuzz`.

**Макросы:**

- `MAP_SIZE` — Пользовательское значение, которое `afl-fuzz` будет использовать для задания размера карты покрытия общей памяти. изначально [зависит от системы](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/include/config.h#L405)
- `MAP_INITIAL_SIZE` — Размер `__afl_area_initial`.


Теперь начнем с `PCGUARD`. Функции инициализации выглядят следующим образом:

![init_func_table](images/init_func_table.png)

Все эти функции (за исключением `sancov.module_ctor_trace_pc_guard`) можно найти в [исходниках](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/instrumentation/afl-compiler-rt.o.c)

Итак, далее мы рассмотрим функции все функции из скриншота выше.

1. `__afl_auto_first` - она по сути [ничего не делает](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/instrumentation/afl-compiler-rt.o.c#L1337), только устанавливает `__afl_already_initialized_first = 1`, чтобы показать, что  был запущен процесс инициализации и проверяет наличие LLVM инструментации.
2. `__afl_auto_second` - сравнивает `__afl_final_loc` и `MAP_INITIAL_SIZE`. Если первый параметр меньше второго, то выделяет доп.память и обновляет все указатели, связанные с [картой покрытия](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/instrumentation/afl-compiler-rt.o.c#L1390)
3. `sancov.module_ctor_trace_pc_guard` - просто обернутый вызов функции `__sanitizer_cov_trace_pc_guard_init`.
   ![cov_trace_pc_guard](images/cov_trace_pc_guard.png)
4. `__afl-auto_eraly` - обертка для вызова  `__afl_map_shm`.
5. `__early_forkserver`- обертка для вызова функции `__afl_auto_init`.
6. `__afl_auto_init` - 

Далее разберем каждую функцию подробнее:

**Рассмотрим функцию** `__sanitizer_cov_trace_pc_guard_init` более [подробно](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/instrumentation/afl-compiler-rt.o.c#L1722):

```C
void __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop) {

  u32   inst_ratio = 100;
  char *x;

  _is_sancov = 1;

...

  if (start == stop || *start) return;

	...

   if (__afl_final_loc < 4) __afl_final_loc = 4;  // we skip the first 5 entries

  *(start++) = ++__afl_final_loc; //start at 4

  while (start < stop) {

    if (likely(inst_ratio == 100) || R(100) < inst_ratio)
      *start = ++__afl_final_loc;
    else
      *start = 0;  // write to map[0]

    start++;

  }
...
```

Эта функция принимает два параметра: `start` и `end`, которые обозначают начало и конец массива меток защиты (guards, как показано в приведённом выше примере). Эти метки фактически составляют карту покрытия - массив состояний покрытия ребер кода.

Суть работы функции заключается в следующем: она последовательно проходит через всю карту покрытия, заполняя её индексами и одновременно увеличивая значение переменной `__afl_final_loc`. В результате выполнения `__afl_final_loc` принимает значение последнего индекса, соответствующего концу массива карты покрытия.

Напомню, что метки защиты (`guards`) привязаны к определённым участкам кода. Эти метки:
- Хранятся в массиве, который фактически является частью карты покрытия.
- Выступают в роли уникальных идентификаторов для различных участков кода.

В тестовом примере из начала статьи такими метками выступали `dword_91A0` и `dword_919C`.

Пара слов об этой строке кода:
```
if (likely(inst_ratio == 100) || R(100) < inst_ratio)
```
Функция `likely` — это макрос или встроенная функция, обычно предоставляемая компилятором. Она помогает оптимизировать выполнение кода, указывая компилятору, что определённое условие с *высокой вероятностью* истинно. В данном случае:

```C
likely(inst_ratio == 100)
```
Указывает, что в большинстве случаев переменная `inst_ratio` будет равна `100`. Это помогает компилятору оптимизировать ветвление для данного условия

`R(100)` — это макрос или функция, которая возвращает случайное число от 0 до 99 (включительно).

Если `inst_ratio == 100`, все метки защиты активируются.
Если `inst_ratio < 100`, метки активируются случайным образом с вероятностью, равной `inst_ratio`.




**Следующая функция** — `__afl_auto_early`. [Эта функция](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/instrumentation/afl-compiler-rt.o.c#L1277) вызывает в себе функцию `__afl_map_shm`.

Для дальнешего обсуждения работы этой функции необходимо пару слов сказать про *разделяему память*. 

  > Разделяемая память — это механизм в Linux, который позволяет создавать области памяти, доступные для нескольких процессов. Каждая область разделяемой памяти имеет собственный уникальный идентификатор (ID), который ее идентифицирует. Чтобы два процесса могли получить доступ к одной и той же разделяемой памяти, им нужно только сопоставить память с одинаковым ID. Для более подробной информации о разделяемой памяти рекомендуется обратиться к странице [руководства](https://man7.org/linux/man-pages/man7/shm_overview.7.html)

По сути, `afl-fuzz` создает экземпляр разделяемой памяти, а целевой процесс сопоставляет дескриптор этой памяти с картой покрытия. В результате `afl-fuzz` может видеть любые изменения, которые дочерний процесс вносит в карту покрытия.


Функция вышла достаточно объемной, поэтому было решение объяснить её работу через комментарии.
Из функции также вырезаны отладочные сообщения, режим CMPlog и режим частичной инструментации кода, а также обработка некоторых ошибок. Полный код функции доступен [тут](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/instrumentation/afl-compiler-rt.o.c#L349)

```C
static void __afl_map_shm(void) {

  // Если разделяемая память уже инициализирована, выходим
  if (__afl_already_initialized_shm) return;
  __afl_already_initialized_shm = 1;

  // Если указатель карты покрытия не установлен, используем заглушку
  if (!__afl_area_ptr) { __afl_area_ptr = __afl_area_ptr_dummy; }

  // Получаем идентификатор разделяемой памяти из переменной окружения
  char *id_str = getenv(SHM_ENV_VAR);

  // Проверяем финальное местоположение карты покрытия
  if (__afl_final_loc) { // !<----------- максмальный размер массива карты покрытия
    __afl_map_size = ++__afl_final_loc;  // Увеличиваем, так как отсчет начинается с 0

     // Если размер больше допустимого MAP_SIZE, предупреждаем пользователя
   if (__afl_final_loc > MAP_SIZE) {
      char *ptr;
      u32 val = 0;
      if ((ptr = getenv("AFL_MAP_SIZE")) != NULL) { val = atoi(ptr); }
      if (val < __afl_final_loc) {
        if (__afl_final_loc > MAP_INITIAL_SIZE && !getenv("AFL_QUIET")) {
          fprintf(stderr,
                  "Warning: AFL++ tools might need to set AFL_MAP_SIZE to %u "
                  "to be able to run this instrumented program if this "
                  "crashes!\n",
                  __afl_final_loc);
        }
      }
    }
  }

  
  // Проверяем, запущено ли приложение под управлением afl-fuzz
  if (__afl_sharedmem_fuzzing && (!id_str || !getenv(SHM_FUZZ_ENV_VAR) ||
                                  fcntl(FORKSRV_FD, F_GETFD) == -1 ||
                                  fcntl(FORKSRV_FD + 1, F_GETFD) == -1)) {
    __afl_sharedmem_fuzzing = 0;
  }

  // Если ID разделяемой памяти отсутствует, инициализируем значения по умолчанию
  if (!id_str) {
   ...
  }

  // Если приложение запущено под AFL++, привязываем карту покрытия
  if (id_str) {
    if (__afl_area_ptr && __afl_area_ptr != __afl_area_initial &&
        __afl_area_ptr != __afl_area_ptr_dummy) {
      if (__afl_map_addr) {
        munmap((void *)__afl_map_addr, __afl_final_loc);  // Освобождаем предыдущую память
      } else {
        free(__afl_area_ptr);  // Освобождаем старую память
      }
      __afl_area_ptr = __afl_area_ptr_dummy;  // Сбрасываем указатель
    }

    // Преобразуем строковый ID в числовой
    u32 shm_id = atoi(id_str);

    // Проверяем, соответствует ли размер карты
    if (__afl_map_size && __afl_map_size > MAP_SIZE) {
      u8 *map_env = (u8 *)getenv("AFL_MAP_SIZE");
      if (!map_env || atoi((char *)map_env) < MAP_SIZE) {
        fprintf(stderr, "FS_ERROR_MAP_SIZE\n");
        send_forkserver_error(FS_ERROR_MAP_SIZE);
        _exit(1);
      }
    }

//-----------------Здесь происходит вся магия---------------
    // Привязываем разделяемую память
    __afl_area_ptr = (u8 *)shmat(shm_id, (void *)__afl_map_addr, 0);

    // Обрабатываем ошибки привязки
    if (!__afl_area_ptr || __afl_area_ptr == (void *)-1) {
      if (__afl_map_addr)
        send_forkserver_error(FS_ERROR_MAP_ADDR);
      else
        send_forkserver_error(FS_ERROR_SHMAT);

      perror("shmat for map");
      _exit(1);
    }

    // Записываем что-либо в карту, чтобы AFL не прекращал работу
    __afl_area_ptr[0] = 1;

   ...
  }

  // Сохраняем резервный указатель на карту
  __afl_area_ptr_backup = __afl_area_ptr;

...
}
```

> Наглядно видно, что основная работа с разделяемой памятью происходит в функции shmat. Подробнее можно прочитать [здесь](https://www.opennet.ru/man.shtml?topic=shmat&category=2&russian=0)

Выполнения данной функции приводит к тому, что `__afl_area_ptr` настроен и располагается в разделяемой (общей) памяти и доступен для всех потомков процесса `afl-fuzz`. Это так же нужно для работы параллельного фаззинга. 


**Теперь перейдем к функции** -  `__early_forkserver`.  Эта [функция](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/instrumentation/afl-compiler-rt.o.c#L1269) зачастую ничего не делает, поэтому пропустим её. 

**Последняя функция** - `__afl_auto_init` - эта [функция](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/instrumentation/afl-compiler-rt.o.c#L1241) вызывает функцию [`__afl_manual_init();`](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/instrumentation/afl-compiler-rt.o.c#L1263), а она в свою очередь [вызывает](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/instrumentation/afl-compiler-rt.o.c#L1232C3) `__afl_start_forkserver();`. Её мы и рассмотрим подробнее:

**Итак, функция**  `__afl_start_forkserver();`. Исходники можно посмотреть [тут](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/instrumentation/afl-compiler-rt.o.c#L855), в рамках статьи же рассмотрим эту функцию тезисно, аналогично функции `__afl_auto_early`:

> Не обходится тут и без небольших шуток от [разработчиков](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/instrumentation/afl-compiler-rt.o.c#L892).


```C
  //Проверяет, используется ли старый режим форксервера (без новых функций). Если __afl_old_forkserver равно 0, выполняется инициализация нового форксервера
  if (!__afl_old_forkserver) {
   
    //Отправляет сообщение родителю через канал. Если отправка не удалась, форксервер завершает выполнение, предполагая, что он не используется.
    if (write(FORKSRV_FD + 1, msg, 4) != 4) { return; }
    //Ожидает ответа от родителя. Если чтение завершилось ошибкой, программа аварийно завершается
    if (read(FORKSRV_FD, reply, 4) != 4) { _exit(1); }
    if (tmp != status2) {

      write_error("wrong forkserver message from AFL++ tool");
      _exit(1);

    }
    ...
    //Устанавливает опции для форксервера
    status = FS_NEW_OPT_MAPSIZE; //Всегда включён, указывает на размер карты покрытия.
    if (__afl_sharedmem_fuzzing) { status |= FS_NEW_OPT_SHDMEM_FUZZ; } //Включается, если используется совместная память для фаззинга.
    if (__afl_dictionary_len && __afl_dictionary) { status |= FS_NEW_OPT_AUTODICT; } //Включается, если доступен автословарь

    //Отправляет опции форксерверу. Завершает выполнение при ошибке записи
    if (write(FORKSRV_FD + 1, msg, 4) != 4) { _exit(1); }
    //Отправляет размер карты покрытия
    status = __afl_map_size;
    if (write(FORKSRV_FD + 1, msg, 4) != 4) { _exit(1); }

    // Далее идет работа с автословарем, опустим
    ...
    //Завершает рукопожатие, отправляя сообщение с версией протокола    
    status = version;
    if (write(FORKSRV_FD + 1, msg, 4) != 4) { _exit(1); }
    //Устанавливает флаг, сигнализирующий, что форксервер подключён к AFL.
    __afl_connected = 1;
    // Если используется совместная память, выполняется её настройка
     if (__afl_sharedmem_fuzzing) { __afl_map_shm_fuzz(); }

     while(1) { ...}
  }

```
Внутри цикла `while(1)` происходит основная работа фаззера. Расписывать построчно его действия не имеет смысла, поэтому тезизсно опишу логику работы программы внутри этого цикла:

Как мы помним - `AFL++`  создает дочерний процесс, через который контролирует запуск уже своих дочерних процессов с помощью функции `fork`.

 > (это необходимо для повышения скорости фаззинга - дочерний процесс главного процесса `AFL++` создает свой fork непосредственно перед запуском исследуемой программы, а поскольку фаззер постоянно перезапускается, таким образом можно не тратить время на новый запуск и инициализацию процесса - возращаемся к исходному состоянию программы перед запуском -> запускаем -> выполняем -> завершаем, собираем покрытие -> убиваем fork и запускаем новый fork с исходным состоянием)


Непосредственно здесь он получает (через каналы) информацию от родительского процесса с тем, а что именно сейчас необходимо делать - если процесс приостановлен (это корректно для режима `persistant mode`, о котором ниже), то запускает его. Если процесс завершен (целевая функция успешно отработала), то создаем новый `fork` дочернего процесса. После этого передаем PID созданного fork'a дочернего процесса в родительский и ожидаем остановки или завершения этого процесса. 

Словом, здесь происходит общение между процессами AFL++ с отслеживанием состояния fork'a - процесса, который непосредственно и запускает целевую программу.

Итак, наш фаззер настроен, запущен и нормально работает. Но есть техники, которые позволяют **существенно** ускорить работу фаззера. Об одной из них ниже.

## AFL++ Persistent Mode

Persistent Mode - это особый режим работы фаззера. Когда фаззер работает в обычном режиме, ему нужно каждый раз запускать fork целевой программы,что может занимать много времени, особенно для сложных или длительных процессов. В `persistent mode` программа запускается один раз, и фаззер использует уже запущенный экземпляр программы для выполнения множества тестов без необходимости перезапуска программы, что значительно ускоряет процесс фаззига. Настоятельно рекомендую почитать [документацию](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/instrumentation/README.persistent_mode.md) на этот мезанизм.

Рассмотрим следующий фрагмент кода с простейшим примером использования `persistant mode`:
```C
#include "what_you_need_for_your_target.h"

#ifndef __AFL_FUZZ_TESTCASE_LEN
  ssize_t fuzz_len;
  #define __AFL_FUZZ_TESTCASE_LEN fuzz_len
  unsigned char fuzz_buf[1024000];
  #define __AFL_FUZZ_TESTCASE_BUF fuzz_buf
  #define __AFL_FUZZ_INIT() void sync(void);
  #define __AFL_LOOP(x) ((fuzz_len = read(0, fuzz_buf, sizeof(fuzz_buf))) > 0 ? 1 : 0)
  #define __AFL_INIT() sync()
#endif

__AFL_FUZZ_INIT();

main() {

  // anything else here, e.g. command line arguments, initialization, etc.

#ifdef __AFL_HAVE_MANUAL_CONTROL
  __AFL_INIT();
#endif

  unsigned char *buf = __AFL_FUZZ_TESTCASE_BUF;  // must be after __AFL_INIT
                                                 // and before __AFL_LOOP!

  while (__AFL_LOOP(10000)) {

    int len = __AFL_FUZZ_TESTCASE_LEN;  // don't use the macro directly in a
                                        // call!

    if (len < 8) continue;  // check for a required/useful minimum input length

    /* Setup function call, e.g. struct target *tmp = libtarget_init() */
    /* Call function to be fuzzed, e.g.: */
    target_function(buf, len);
    /* Reset state. e.g. libtarget_free(tmp) */

  }

  return 0;
}
```

Наглядно видно, что макросы AFL++ разворчаиваются в достаточно простые команды, которые создают статический массив для входных данных 
`fuzz_buf`, считывают в него данные функцией `read` и записывают длину полуенного массива в `fuzz_len`. 
Фактически архитектурно работа фаззера здесь представлена также, как и в обычном режиме фаззера - подаются данные (обычно из потока ввода) на вход программы, программа запускается, выполняется, собирается обратная связь. Здесь же все тоже самое, но данные подаются напрямую на функцию цель, а fork программы не завершается после выполнения программы, а выполняется в цикле `__AFL_LOOP`.

Запуск фаззера в `persistant mode` так же влияет на [процесс работы](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/instrumentation/afl-compiler-rt.o.c#L1081) `forkserver'a`:
```C
if (unlikely(waitpid(child_pid, &status, is_persistent ? WUNTRACED : 0) < 0)) {
  write_error("waitpid");
  _exit(1);
}
```

Если фаззинг запушен в режиме `persistant mode`, то мы ждем, пока дочерний процесс не **остановится** `(WUNTRACED)`, а не **завершится**. Причина этого кроется в макросе `__AFL_LOOP`, который расширяется в функцию `__afl_persistent_loop`. [Исходник функции](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/instrumentation/afl-compiler-rt.o.c#L1111)

Идея этой функции в том, что существует статическая переменная `cycle_cnt`, которая отвечает за количество оставшихся циклов. В конце каждого цикла (кроме случая, когда `cycle_cnt = 0`, в этом случае происходит остановка), [посылается сигнал](https://github.com/AFLplusplus/AFLplusplus/blob/24503fba5fd2580559223ec3c6ee408dfa15e080/instrumentation/afl-compiler-rt.o.c#L1282) `SIGSTOP` . Это вызывает выполнение условия `waitpid`, что позволяет `afl-fuzz` выполнить свои мутации и обновить карту покрытия. Как только управление возвращается в форксервер, бинарник возобновляется с [помощью сигнала]() `SIGCONT` - еще раз внимательно смотрим код [функции](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/instrumentation/afl-compiler-rt.o.c#L1067) `__afl_start_forkserver`


### Пара слов про санитайзеры кода

AFL++, несмотря на инструментацию кода, не умеет определять какие-либо ошибки кода, поэтому очень важно использовать санитайзеры. Тестируя программу без вы рискуете не отследить огромный объем ошибок.

Существует множество типов санитайзеров, каждый из которых предназначен для обнаружения различных видов ошибок, включая недопустимые обращения к памяти (например, использование после освобождения — UAF), использование неинициализированной памяти и неопределённое поведение и прочее.

Особенность работы санитайзеров напрашивается на отдельную статью, благо Google опубликовал отличный вики-ресурс, который описывает каждый санитайзер и его реализацию - искать [тут](https://github.com/google/sanitizers/wiki).




## Инициализация `afl-fuzz`

Чтобы понять, как работает `AFL++`, полезно взглянуть на исходный код функции `afl_fuzz`.

Есть две ключевые структуры, на которые мы будем обращать внимание: [afl_state_t](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/include/afl-fuzz.h#L489) и [afl_forkserver_t](https://github.com/AFLplusplus/AFLplusplus/blob/10db3a35cf17600594946edb6662d606bd4e4207/include/forkserver.h#L102).

- `afl_state_t` — это структура, которая управляет самим фаззером и множеством его параметров, включая параметры мутатора, наблюдателей, фидбеков и другие.

- `afl_forkserver_t` — это структура, которая управляет форк-сервером. Форк-сервер — это компонент, который выполняет целевой бинарный файл. Эта структура также содержит другую ключевую информацию, включая входной файл и параметры, связанные с тем, что делает форк-сервер (например, работает ли он в режиме Nyx или QEMU?). `afl_forkserver_t` встроен в `afl_state_t`.

Для инициализации `afl-fuzz` мы начинаем с [функции](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/src/afl-fuzz.c#L545) `main` в `afl-fuzz.c`. Здесь много всего, и большинство из этого связано с обработкой специфияных случаев работы программы, таких как режимы QEMU, Nyx, Frida и другие.

Первое важное действие в функции `main`— это получение `map_size`. Это размер карты покрытия в общей памяти. Чтобы получить `map_size`, вызывается [функция](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/src/afl-fuzz.c#L550) `get_map_size`, которая выглядит [вот так](https://github.com/AFLplusplus/AFLplusplus/blob/v4.30c/src/afl-common.c#L1359C1):

```C
/* Reads the map size from ENV */
u32 get_map_size(void) {

  uint32_t map_size = DEFAULT_SHMEM_SIZE;
  char    *ptr;

  if ((ptr = getenv("AFL_MAP_SIZE")) || (ptr = getenv("AFL_MAPSIZE"))) {

    map_size = atoi(ptr);
    if (!map_size || map_size > (1 << 29)) {

      FATAL("illegal AFL_MAP_SIZE %u, must be between %u and %u", map_size, 64U,
            1U << 29);

    }

    if (map_size % 64) { map_size = (((map_size >> 6) + 1) << 6); }

  } else if (getenv("AFL_SKIP_BIN_CHECK")) {

    map_size = MAP_SIZE;

  }

  return map_size;

}
```


